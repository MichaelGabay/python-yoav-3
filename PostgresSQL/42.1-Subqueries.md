# תת-שאילתות (Subqueries) ב-PostgreSQL

## מהי תת-שאילתה?

תת-שאילתה (Subquery) היא שאילתת SQL שנמצאת בתוך שאילתה אחרת. היא מאפשרת לנו לבצע חישובים מורכבים ולקבל מידע מתוך טבלאות מרובות בצורה יעילה.

## מתי נדרש להשתמש בתת-שאילתות?

תת-שאילתות נדרשות כאשר:

1. **צריך לעשות חישוב לפני השוואה** - למשל, למצוא מוצרים שזולים יותר מהממוצע
2. **צריך לבדוק קיום** - למשל, למצוא לקוחות שיש להם הזמנות
3. **צריך לעבוד עם ערכים מרובים** - למשל, למצוא מוצרים ששייכים לקטגוריות מסוימות
4. **צריך לסנן לפי תוצאה של שאילתה אחרת** - למשל, למצוא את העובד עם המשכורת הגבוהה ביותר
5. **צריך לבצע חישובים מורכבים** - למשל, למצוא את ההפרש בין מחיר מוצר לממוצע המחירים

## תחביר בסיסי

### תת-שאילתה ב-SELECT

```sql
SELECT 
    column1,
    (SELECT AVG(price) FROM products) AS avg_price
FROM products;
```

### תת-שאילתה ב-WHERE

```sql
SELECT *
FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

### תת-שאילתה ב-FROM

```sql
SELECT *
FROM (SELECT * FROM products WHERE price > 100) AS expensive_products;
```

### תת-שאילתה ב-IN

```sql
SELECT *
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders);
```

## סוגי תת-שאילתות

### 1. תת-שאילתה סקלרית (Scalar Subquery)

מחזירה ערך יחיד (שורה אחת, עמודה אחת).

```sql
-- מצא את כל המוצרים שזולים יותר מהממוצע
SELECT *
FROM products
WHERE price < (SELECT AVG(price) FROM products);
```

```sql
-- מצא את שם הלקוח עם ההזמנה האחרונה
SELECT customer_name
FROM customers
WHERE customer_id = (
    SELECT customer_id 
    FROM orders 
    ORDER BY order_date DESC 
    LIMIT 1
);
```

### 2. תת-שאילתה מרובת שורות (Multiple Row Subquery)

מחזירה מספר שורות.

#### עם IN

```sql
-- מצא את כל הלקוחות שיש להם הזמנות
SELECT *
FROM customers
WHERE customer_id IN (
    SELECT DISTINCT customer_id 
    FROM orders
);
```

#### עם ANY/SOME

```sql
-- מצא מוצרים שמחירם גדול מכל מחיר בטבלת sales
SELECT *
FROM products
WHERE price > ANY (
    SELECT sale_price 
    FROM sales
);
```

#### עם ALL

```sql
-- מצא מוצרים שמחירם גדול מכל מחיר בטבלת sales
SELECT *
FROM products
WHERE price > ALL (
    SELECT sale_price 
    FROM sales
);
```

### 3. תת-שאילתה קורלטיבית (Correlated Subquery)

תת-שאילתה שמתייחסת לעמודות מהשאילתה החיצונית.

```sql
-- מצא את כל המוצרים שמחירם גבוה מהממוצע בקטגוריה שלהם
SELECT *
FROM products p1
WHERE price > (
    SELECT AVG(price)
    FROM products p2
    WHERE p2.category_id = p1.category_id
);
```

```sql
-- מצא את כל הלקוחות שיש להם יותר מ-5 הזמנות
SELECT *
FROM customers c
WHERE (
    SELECT COUNT(*)
    FROM orders o
    WHERE o.customer_id = c.customer_id
) > 5;
```

### 4. תת-שאילתה עם EXISTS

בודקת אם קיימת שורה אחת לפחות.

```sql
-- מצא לקוחות שיש להם הזמנות
SELECT *
FROM customers c
WHERE EXISTS (
    SELECT 1
    FROM orders o
    WHERE o.customer_id = c.customer_id
);
```

```sql
-- מצא מוצרים שלא נמכרו מעולם
SELECT *
FROM products p
WHERE NOT EXISTS (
    SELECT 1
    FROM order_items oi
    WHERE oi.product_id = p.product_id
);
```

## שימוש ב-WITH (CTE - Common Table Expression)

`WITH` מאפשר לנו ליצור תת-שאילתות עם שמות, מה שהופך את הקוד לקריא יותר וניתן לשימוש חוזר.

### תחביר בסיסי של WITH

```sql
WITH cte_name AS (
    SELECT ...
)
SELECT * FROM cte_name;
```

### דוגמה פשוטה

```sql
-- מצא את הממוצע ואז את כל המוצרים שמחירם גבוה מהממוצע
WITH avg_price AS (
    SELECT AVG(price) AS avg_val
    FROM products
)
SELECT *
FROM products, avg_price
WHERE products.price > avg_price.avg_val;
```

### WITH מרובה (Multiple CTEs)

```sql
-- חישוב מורכב עם מספר CTEs
WITH 
    total_sales AS (
        SELECT 
            product_id,
            SUM(quantity * price) AS total
        FROM order_items
        GROUP BY product_id
    ),
    avg_sales AS (
        SELECT AVG(total) AS avg_total
        FROM total_sales
    )
SELECT 
    p.product_name,
    ts.total
FROM products p
JOIN total_sales ts ON p.product_id = ts.product_id
CROSS JOIN avg_sales
WHERE ts.total > avg_sales.avg_total;
```

### CTE רקורסיבי (Recursive CTE)

```sql
-- יצירת רשימה של מספרים מ-1 עד 10
WITH RECURSIVE numbers AS (
    -- Anchor member
    SELECT 1 AS n
    UNION ALL
    -- Recursive member
    SELECT n + 1
    FROM numbers
    WHERE n < 10
)
SELECT * FROM numbers;
```

```sql
-- מצא את כל העובדים הכפופים לעובד מסוים (היררכיה)
WITH RECURSIVE employee_hierarchy AS (
    -- Anchor: העובד הבסיסי
    SELECT 
        employee_id,
        employee_name,
        manager_id,
        1 AS level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive: כל העובדים הכפופים
    SELECT 
        e.employee_id,
        e.employee_name,
        e.manager_id,
        eh.level + 1
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM employee_hierarchy;
```

## יכולות מתקדמות

### 1. תת-שאילתה ב-JOIN

```sql
-- הצטרף לתוצאה של תת-שאילתה
SELECT 
    c.customer_name,
    order_summary.total_orders
FROM customers c
JOIN (
    SELECT 
        customer_id,
        COUNT(*) AS total_orders
    FROM orders
    GROUP BY customer_id
) AS order_summary ON c.customer_id = order_summary.customer_id;
```

### 2. תת-שאילתה ב-HAVING

```sql
-- מצא קטגוריות שהממוצע שלהן גבוה מהממוצע הכללי
SELECT 
    category_id,
    AVG(price) AS avg_price
FROM products
GROUP BY category_id
HAVING AVG(price) > (
    SELECT AVG(price)
    FROM products
);
```

### 3. תת-שאילתה ב-INSERT

```sql
-- הוסף הזמנות חדשות על בסיס לקוחות קיימים
INSERT INTO orders (customer_id, order_date)
SELECT 
    customer_id,
    CURRENT_DATE
FROM customers
WHERE customer_id NOT IN (
    SELECT DISTINCT customer_id 
    FROM orders
);
```

### 4. תת-שאילתה ב-UPDATE

```sql
-- עדכן מחירים לפי הממוצע בקטגוריה
UPDATE products
SET price = (
    SELECT AVG(price)
    FROM products p2
    WHERE p2.category_id = products.category_id
)
WHERE price IS NULL;
```

### 5. תת-שאילתה ב-DELETE

```sql
-- מחק מוצרים שלא נמכרו מעולם
DELETE FROM products
WHERE product_id NOT IN (
    SELECT DISTINCT product_id
    FROM order_items
);
```

### 6. תת-שאילתה עם WINDOW Functions

```sql
-- מצא את המוצר היקר ביותר בכל קטגוריה
SELECT *
FROM (
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY price DESC) AS rn
    FROM products
) AS ranked_products
WHERE rn = 1;
```

### 7. תת-שאילתה עם UNION

```sql
-- איחוד של תוצאות מתת-שאילתות
(
    SELECT product_id, product_name, price
    FROM products
    WHERE price > 100
)
UNION ALL
(
    SELECT product_id, product_name, price
    FROM products
    WHERE price < 50
);
```

## השוואה: תת-שאילתות מול JOINs

### מתי להשתמש בתת-שאילתה?

- כאשר צריך **לספור או לחשב** לפני השוואה
- כאשר צריך לבדוק **קיום** (EXISTS)
- כאשר השאילתה **פשוטה יותר לקריאה** עם תת-שאילתה
- כאשר צריך **למנוע כפילויות** (DISTINCT מורכב)

### מתי להשתמש ב-JOIN?

- כאשר צריך **לשלב עמודות** מטבלאות שונות
- כאשר השאילתה **יעילה יותר** עם JOIN
- כאשר צריך **לסנן לפי תנאים** מטבלאות מרובות

### דוגמה להשוואה

**עם תת-שאילתה:**
```sql
SELECT *
FROM customers
WHERE customer_id IN (
    SELECT customer_id 
    FROM orders 
    WHERE order_date > '2024-01-01'
);
```

**עם JOIN:**
```sql
SELECT DISTINCT c.*
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date > '2024-01-01';
```

## טיפים לביצועים

1. **השתמש ב-EXISTS במקום IN** כאשר תת-שאילתה יכולה להחזיר הרבה שורות
   ```sql
   -- טוב יותר
   WHERE EXISTS (SELECT 1 FROM ...)
   
   -- פחות יעיל
   WHERE id IN (SELECT id FROM ...)
   ```

2. **הימנע מתת-שאילתות קורלטיביות** כאשר אפשר להשתמש ב-JOIN
   ```sql
   -- פחות יעיל
   WHERE price > (SELECT AVG(price) FROM products p2 WHERE p2.category_id = p1.category_id)
   
   -- יעיל יותר
   JOIN (SELECT category_id, AVG(price) AS avg_price FROM products GROUP BY category_id) AS avg
   ```

3. **השתמש ב-WITH** לשאילתות מורכבות - זה משפר קריאות ומאפשר אופטימיזציה

4. **הוסף אינדקסים** על עמודות שמשמשות בתת-שאילתות

## תרגילים

### תרגיל 1
מצא את כל המוצרים שמחירם גבוה מהממוצע הכללי.

### תרגיל 2
מצא את כל הלקוחות שיש להם יותר מ-3 הזמנות.

### תרגיל 3
מצא את המוצר היקר ביותר בכל קטגוריה.

### תרגיל 4
מצא את כל העובדים שמשכורתם גבוהה מהממוצע במחלקה שלהם.

### תרגיל 5
מצא את כל המוצרים שלא נמכרו בחודש האחרון.

### תרגיל 6
השתמש ב-WITH כדי למצוא את הלקוח עם המכירות הגבוהות ביותר.

### תרגיל 7
צור CTE רקורסיבי שמציג את כל הקטגוריות והיררכיית הקטגוריות שלהן.

### תרגיל 8
מצא את כל ההזמנות שהסכום שלהן גבוה מהממוצע של כל ההזמנות.

---

## פתרונות

<details>
<summary>לחץ כדי לראות פתרונות</summary>

### תרגיל 1
```sql
SELECT *
FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

### תרגיל 2
```sql
SELECT *
FROM customers c
WHERE (
    SELECT COUNT(*)
    FROM orders o
    WHERE o.customer_id = c.customer_id
) > 3;
```

### תרגיל 3
```sql
SELECT *
FROM products p1
WHERE price = (
    SELECT MAX(price)
    FROM products p2
    WHERE p2.category_id = p1.category_id
);
```

או עם WITH:
```sql
WITH max_prices AS (
    SELECT 
        category_id,
        MAX(price) AS max_price
    FROM products
    GROUP BY category_id
)
SELECT p.*
FROM products p
JOIN max_prices mp ON p.category_id = mp.category_id AND p.price = mp.max_price;
```

### תרגיל 4
```sql
SELECT *
FROM employees e1
WHERE salary > (
    SELECT AVG(salary)
    FROM employees e2
    WHERE e2.department_id = e1.department_id
);
```

### תרגיל 5
```sql
SELECT *
FROM products p
WHERE NOT EXISTS (
    SELECT 1
    FROM order_items oi
    JOIN orders o ON oi.order_id = o.order_id
    WHERE oi.product_id = p.product_id
    AND o.order_date >= CURRENT_DATE - INTERVAL '1 month'
);
```

### תרגיל 6
```sql
WITH customer_sales AS (
    SELECT 
        c.customer_id,
        c.customer_name,
        SUM(oi.quantity * oi.price) AS total_sales
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY c.customer_id, c.customer_name
)
SELECT *
FROM customer_sales
WHERE total_sales = (SELECT MAX(total_sales) FROM customer_sales);
```

### תרגיל 7
```sql
WITH RECURSIVE category_hierarchy AS (
    -- Anchor: קטגוריות ראשיות (ללא parent)
    SELECT 
        category_id,
        category_name,
        parent_category_id,
        1 AS level,
        category_name::TEXT AS path
    FROM categories
    WHERE parent_category_id IS NULL
    
    UNION ALL
    
    -- Recursive: קטגוריות בנות
    SELECT 
        c.category_id,
        c.category_name,
        c.parent_category_id,
        ch.level + 1,
        (ch.path || ' > ' || c.category_name)::TEXT
    FROM categories c
    JOIN category_hierarchy ch ON c.parent_category_id = ch.category_id
)
SELECT * FROM category_hierarchy ORDER BY path;
```

### תרגיל 8
```sql
WITH order_totals AS (
    SELECT 
        order_id,
        SUM(quantity * price) AS total_amount
    FROM order_items
    GROUP BY order_id
),
avg_order AS (
    SELECT AVG(total_amount) AS avg_amount
    FROM order_totals
)
SELECT 
    o.*,
    ot.total_amount
FROM orders o
JOIN order_totals ot ON o.order_id = ot.order_id
CROSS JOIN avg_order
WHERE ot.total_amount > avg_order.avg_amount;
```

</details>
